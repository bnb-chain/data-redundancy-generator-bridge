// The "main" package retrieves the data redundancy from the [greenfield-common] Go library,
// making it accessible in Python.
//
// [greenfield-common]: https://github.com/bnb-chain/greenfield-common
package main

import (
	"C"
	"bytes"
	"unsafe"

	lib "github.com/bnb-chain/greenfield-common/go/hash"
)

// GenerateDataRedundancy returns the data redundancy used in [greenfield], corresponding to the provided data.
// The data is passed as a string and converted to a byte array using it's length. The data redundancy bytes array
// is generated by passing the `data`, the segment size of the data `segmentSize`, the number of data blocks
// `dataBlocks` and the number of parity blocks `parityBlocks` to the Greenfield function `ComputeIntegrityHash`.
// An array of piece hash roots is returned and then concatenated into a single byte array. This byte array is then
// returned as a string.
//
// [greenfield]: https://github.com/bnb-chain/greenfield-whitepaper/blob/main/part3.md#182-erasure-code-and-data-redundancy

//export GenerateDataRedundancy
func GenerateDataRedundancy(segmentSize int, dataBlocks int, parityBlocks int, length C.int, data *C.char, isSerial *C.char) *C.char {
	initial_bytes := C.GoBytes(unsafe.Pointer(data), length)
	reader := bytes.NewReader(initial_bytes)
	serial := true
	if C.GoString(isSerial) == "false" {
		serial = false
	}
	pieceHashRoots, _, _, err := lib.ComputeIntegrityHash(reader, int64(segmentSize), dataBlocks, parityBlocks, serial)
	if err != nil {
		errMsg := C.CString(err.Error())
		return errMsg
	}
	concatenated := bytes.Join(pieceHashRoots, []byte{})

	return C.CString(string(concatenated))
}

func main() {

}
